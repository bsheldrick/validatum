{"version":3,"sources":["webpack:///./src/components/inlineCode.tsx","webpack:///./src/pages/advanced/extension-methods.tsx","webpack:///./src/components/validatorFuncs.tsx"],"names":["InlineCode","code","className","children","rest","classes","ExtensionMethods","to","label","ValidatorFunction","name","description","methods","brokenRule","id","map","method","CodeExample"],"mappings":"wKAwBeA,IAjByB,SAAC,GAKnC,IAJJC,EAII,EAJJA,KACAC,EAGI,EAHJA,UACAC,EAEI,EAFJA,SACGC,E,oIACC,oCACAC,EAAU,cAId,OAHIH,IACFG,EAAaA,EAAN,IAAiBH,GAGxB,wCAAMA,UAAWG,GAAaD,GAC3BH,GAAcE,K,kCCnBrB,gFAqNeG,UArFf,WACE,OACE,kBAAC,IAAD,KACE,2DACA,+GAEgB,kBAAC,IAAD,CAAYL,KAAK,yBAFjC,eAIA,wBAAIC,UAAU,SACd,2DACA,wHAIA,wBAAIA,UAAU,6CACZ,mGAGA,wCACY,IACV,4BACE,wCACI,IAJR,4DAOA,+CACmB,IACjB,4BACE,wCACI,IAJR,MAKM,IACJ,4BACE,4CACI,IARR,eAWA,gDACoB,IAClB,4BACE,4CACI,IAJR,uBAOA,wHAE2B,IACzB,kBAAC,OAAD,CAAMK,GAAG,oCAAT,gCAEQ,IALV,WAMU,kBAAC,OAAD,CAAMA,GAAG,2BAAT,OANV,0BASA,4BACE,yCADF,aACkC,kBAAC,IAAD,CAAYN,KAAK,YAAa,IADhE,cAKF,mHAEkB,IAChB,4BACE,mDACI,IALR,UAMU,IACR,4BACE,qDARJ,oCAYA,wBAAIC,UAAU,4BAAd,WACA,kBAAC,IAAD,CAAaD,KAhMG,qqGAiMhB,kBAAC,IAAD,CAAaA,KApHE,4UAoHkBO,MAAM,+BACvC,kBAAC,IAAD,CAAaP,KAtGK,oZAsGkBO,MAAM,8BAC1C,kBAAC,IAAD,CACEP,KAzFW,kaA0FXO,MACE,6CACQ,kBAAC,IAAD,YADR,mB,iKCjMGC,EAAuC,SAAC,GAM/C,IALJC,EAKI,EALJA,KACAC,EAII,EAJJA,YACAC,EAGI,EAHJA,QACAC,EAEI,EAFJA,WACAV,EACI,EADJA,SAEA,OACE,yBAAKD,UAAU,OAAOY,GAAIJ,GACxB,wBAAIR,UAAU,iBAAiBQ,GAC/B,2BAAIC,GACJ,wBAAIT,UAAU,4CAAd,WACCU,EAAQG,KAAI,SAACC,GAAD,OACX,oCACE,kBAAC,IAAD,CAAYd,UAAU,mDACnBc,GAEH,iCAGJ,wBAAId,UAAU,4CAAd,eACA,uBAAGA,UAAU,4DACVW,GAEH,wBAAIX,UAAU,4CAAd,iBAGCC,IAUMc,EAAoC,SAAC,GAAD,IAAGT,EAAH,EAAGA,MAAOP,EAAV,EAAUA,KAAV,OAC/C,oCACGO,GAAS,uBAAGN,UAAU,gCAAgCM,GACvD,kBAAC,IAAD,CAAQP,KAAMA","file":"component---src-pages-advanced-extension-methods-tsx-7c46cd3b59eba076352e.js","sourcesContent":["import React, { FC } from \"react\"\n\ntype InlineCodeProps = {\n  code?: string\n  className?: string\n}\n\nconst InlineCode: FC<InlineCodeProps> = ({\n  code,\n  className,\n  children,\n  ...rest\n}) => {\n  let classes = \"inline-code\"\n  if (className) {\n    classes = `${classes} ${className}`\n  }\n  return (\n    <span className={classes} {...rest}>\n      {code ? code : children}\n    </span>\n  )\n}\n\nexport default InlineCode\n","import { Link } from \"gatsby\"\nimport React, { ReactElement } from \"react\"\nimport InlineCode from \"../../components/inlineCode\"\nimport Layout from \"../../components/layout\"\nimport { CodeExample } from \"../../components/validatorFuncs\"\n\nconst extendExample = `using System;\nusing System.Linq.Expressions;\nusing Validatum; // namespace of IValidatorBuilder<T>\n\nnamespace MyProject\n{\n    public static class ValidatorBuilderExtensions\n    {\n        /// <summary>\n        /// Adds a validator to ensure the integer value is not thirteen.\n        /// </summary>\n        public static IValidatorBuilder<int> NotThirteen(this IValidatorBuilder<int> builder,\n            string key = null,\n            string message = null)\n        {\n            if (builder is null)\n            {\n                throw new ArgumentNullException(nameof(builder));\n            }\n\n            // ============================================================ //\n            // Anything outside the 'builder' is the building phase.        //\n            // Code here will execute when the Build() method is called on  //\n            // the builder.                                                 //\n            // ============================================================ //\n\n            return builder\n                .When(\n                    ctx => ctx.Value == 13,\n                    ctx => \n                    {\n                        // ============================================================ //\n                        // Anything inside the 'builder' is the validation phase.       //\n                        // Code here will execute when the Validate() method is called  //\n                        // on the validator.                                            //\n                        // ============================================================ //\n\n                        // use the name of the extension method as broken rule name\n                        // key and message passed to broken rule with default message if null\n                        ctx.AddBrokenRule(\n                            nameof(NotThirteen), \n                            key, \n                            message ?? \"Value cannot equal 13.\");\n                    });\n        }\n\n        /// <summary>\n        /// Adds a validator to ensure the integer value is not thirteen \n        /// for the target of the selector expression.\n        /// </summary>\n        public static IValidatorBuilder<T> NotThirteen<T>(this IValidatorBuilder<T> builder, \n            Expression<Func<T, int>> selector, // make sure your expression targets the correct type\n            string key = null,\n            string message = null)\n        {\n            if (builder is null)\n            {\n                throw new ArgumentNullException(nameof(builder));\n            }\n\n            if (selector is null)\n            {\n                throw new ArgumentNullException(nameof(selector));\n            }\n\n            // set the key to use the path of the selected property if a key has not been provided\n            // e.g. with selector expression 't => t.Address.AddressLine1'\n            //      key will be 'Address.AddressLine1'\n            key = key ?? selector.GetPropertyPath();\n\n            // use the For function to call your validation function\n            return builder.For<T, int>(selector, p => p.NotThirteen(key, message));\n        }\n    }\n}\n`\n\nconst usageExample = `var validator = new ValidatorBuilder<int>()\n    .GreaterThan(10)\n    .NotThirteen()\n    .LessThan(20)\n    .Build();\n\nvar result = validator.Validate(13);\nvar rule = result.BrokenRules.First();\n\nConsole.WriteLine($\"[{rule.Rule}] {rule.Key}: {rule.Message}\");\n\n// output\n// [NotThirteen] Int32: Value cannot equal 13.\n`\n\nconst selectorExample = `var validator = new ValidatorBuilder<Person>()\n    .GreaterThan(p => p.Age, 10)\n    .NotThirteen(p => p.Age)\n    .LessThan(p => p.Age, 20)\n    .Build();\n\nvar result = validator.Validate(new Person { Name = \"Steve\", Age = 13 });\nvar rule = result.BrokenRules.First();\n\nConsole.WriteLine($\"[{rule.Rule}] {rule.Key}: {rule.Message}\");\n\n// output\n// [NotThirteen] Age: Value cannot equal 13.\n`\n\nconst forExample = `var validator = new ValidatorBuilder<Person>()\n    .GreaterThan(p => p.Age, 10)\n    .For(p => p.Age, a => a.NotThirteen())\n    .LessThan(p => p.Age, 20)\n    .Build();\n\nvar result = validator.Validate(new Person { Name = \"Steve\", Age = 13 });\nvar rule = result.BrokenRules.First();\n\nConsole.WriteLine($\"[{rule.Rule}] {rule.Key}: {rule.Message}\");\n\n// output\n// [NotThirteen] Age: Value cannot equal 13.\n`\n\nfunction ExtensionMethods(): ReactElement {\n  return (\n    <Layout>\n      <h1>Extending IValidatorBuilder</h1>\n      <p>\n        Validatum is easy to extend by creating your own extension methods\n        targeting the <InlineCode code=\"IValidatorBuilder<T>\" /> interface.\n      </p>\n      <hr className=\"my-6\" />\n      <h2>Writing an extension method</h2>\n      <p>\n        There are some golden rules to follow to ensure you build high quality\n        extension methods.\n      </p>\n      <ul className=\"list-disc list-inside ml-4 my-4 space-y-2\">\n        <li>\n          Use the extension method name as the rule name for the broken rule.\n        </li>\n        <li>\n          Provide a{\" \"}\n          <em>\n            <strong>For</strong>\n          </em>{\" \"}\n          function overload method that has a selector expression.\n        </li>\n        <li>\n          Provide optional{\" \"}\n          <em>\n            <strong>key</strong>\n          </em>{\" \"}\n          and{\" \"}\n          <em>\n            <strong>message</strong>\n          </em>{\" \"}\n          parameters.\n        </li>\n        <li>\n          Provide a default{\" \"}\n          <em>\n            <strong>message</strong>\n          </em>{\" \"}\n          to the broken rule.\n        </li>\n        <li>\n          Don't use other validation functions in your validation function\n          (don't chain functions).{\" \"}\n          <Link to=\"/building/conditional-functions/\">\n            Conditional When and WhenNot\n          </Link>{\" \"}\n          and the <Link to=\"/building/for-function/\">For</Link> function can be\n          used.\n        </li>\n        <li>\n          <strong>DON'T</strong> call the <InlineCode code=\"Build()\" />{\" \"}\n          function.\n        </li>\n      </ul>\n      <p>\n        It's also important to understand the extension method is executed in\n        two phases, the{\" \"}\n        <em>\n          <strong>building phase</strong>\n        </em>{\" \"}\n        and the{\" \"}\n        <em>\n          <strong>validation phase</strong>\n        </em>\n        . See comments in example below.\n      </p>\n      <h3 className=\"my-4 font-bold text-base\">Example</h3>\n      <CodeExample code={extendExample} />\n      <CodeExample code={usageExample} label=\"Using the extension method\" />\n      <CodeExample code={selectorExample} label=\"Using selector expression\" />\n      <CodeExample\n        code={forExample}\n        label={\n          <>\n            Using <InlineCode>For</InlineCode> function.\n          </>\n        }\n      />\n    </Layout>\n  )\n}\n\nexport default ExtensionMethods\n","import React, { FC } from \"react\"\nimport InlineCode from \"./inlineCode\"\nimport CSharp from \"./csharp\"\n\ntype FunctionProps = {\n  name: string\n  description: string\n  methods: string[]\n  brokenRule?: string\n}\n\nexport const ValidatorFunction: FC<FunctionProps> = ({\n  name,\n  description,\n  methods,\n  brokenRule,\n  children,\n}) => {\n  return (\n    <div className=\"mb-4\" id={name}>\n      <h2 className=\"font-semibold\">{name}</h2>\n      <p>{description}</p>\n      <h5 className=\"font-semibold text-gray-800 text-sm my-4\">Methods</h5>\n      {methods.map((method) => (\n        <>\n          <InlineCode className=\"text-sm font-semibold text-blue-600 bg-blue-100\">\n            {method}\n          </InlineCode>\n          <br />\n        </>\n      ))}\n      <h5 className=\"font-semibold text-gray-800 text-sm my-4\">Broken Rule</h5>\n      <p className=\"font-semibold font-mono text-sm text-red-600 inline px-1\">\n        {brokenRule}\n      </p>\n      <h5 className=\"font-semibold text-gray-800 text-sm mt-4\">\n        Example Usage\n      </h5>\n      {children}\n    </div>\n  )\n}\n\ntype CodeExampleProps = {\n  code: string\n  label?: string | JSX.Element\n}\n\nexport const CodeExample: FC<CodeExampleProps> = ({ label, code }) => (\n  <>\n    {label && <p className=\"text-gray-700 mb-0 pb-0 mt-4\">{label}</p>}\n    <CSharp code={code} />\n  </>\n)\n"],"sourceRoot":""}