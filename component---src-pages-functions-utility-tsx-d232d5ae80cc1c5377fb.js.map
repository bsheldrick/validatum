{"version":3,"sources":["webpack:///./src/components/inlineCode.tsx","webpack:///./src/pages/functions/utility.tsx","webpack:///./src/components/validatorFuncs.tsx"],"names":["InlineCode","code","className","children","rest","classes","UtilityFunctions","map","func","to","UtilityMethod","name","description","methods","label","id","method","ValidatorFunction","brokenRule","CodeExample"],"mappings":"yKAwBeA,IAjByB,SAAC,GAKnC,IAJJC,EAII,EAJJA,KACAC,EAGI,EAHJA,UACAC,EAEI,EAFJA,SACGC,E,oIACC,oCACAC,EAAU,cAId,OAHIH,IACFG,EAAaA,EAAN,IAAiBH,GAGxB,wCAAMA,UAAWG,GAAaD,GAC3BH,GAAcE,K,8HC+FNG,UA/Cf,WACE,OACE,kBAAC,IAAD,KACE,iDACA,4GAIA,2BACE,wBAAIJ,UAAU,QACX,CAAC,UAAW,WAAWK,KAAI,SAACC,GAAD,OAC1B,4BACE,kBAAC,OAAD,CAAMC,GAAE,uBAAyBD,GAASA,SAKlD,wBAAIN,UAAU,SACd,kBAACQ,EAAD,CACEC,KAAK,UACLC,YAAY,qGACZC,QAAS,CACP,mGAGF,kBAAC,IAAD,CAAaZ,KAtFE,ylBAwFjB,wBAAIC,UAAU,SACd,kBAACQ,EAAD,CACEC,KAAK,UACLC,YAAY,2KAEZC,QAAS,CACP,6BACA,wDAGF,kBAAC,IAAD,CAAaZ,KA1EG,ybA0EoBa,MAAM,yBAC1C,kBAAC,IAAD,CACEb,KA1Dc,+gBA2Dda,MAAM,uCAehB,IAAMJ,EAAwC,SAAC,GAAD,IAC5CC,EAD4C,EAC5CA,KACAC,EAF4C,EAE5CA,YACAC,EAH4C,EAG5CA,QACAV,EAJ4C,EAI5CA,SAJ4C,OAM5C,yBAAKD,UAAU,OAAOa,GAAIJ,GACxB,wBAAIT,UAAU,iBAAiBS,GAC/B,uBAAGT,UAAU,QAAQU,GACrB,wBAAIV,UAAU,uCAAd,UACA,yBAAKA,UAAU,QACZW,EAAQN,KAAI,SAACS,GAAD,OACX,oCACE,kBAAC,IAAD,CAAYd,UAAU,mDACnBc,GAEH,kCAIN,wBAAId,UAAU,uCAAd,iBACCC,K,iKCpIQc,EAAuC,SAAC,GAM/C,IALJN,EAKI,EALJA,KACAC,EAII,EAJJA,YACAC,EAGI,EAHJA,QACAK,EAEI,EAFJA,WACAf,EACI,EADJA,SAEA,OACE,yBAAKD,UAAU,OAAOa,GAAIJ,GACxB,wBAAIT,UAAU,iBAAiBS,GAC/B,2BAAIC,GACJ,wBAAIV,UAAU,4CAAd,WACCW,EAAQN,KAAI,SAACS,GAAD,OACX,oCACE,kBAAC,IAAD,CAAYd,UAAU,mDACnBc,GAEH,iCAGJ,wBAAId,UAAU,4CAAd,eACA,uBAAGA,UAAU,4DACVgB,GAEH,wBAAIhB,UAAU,4CAAd,iBAGCC,IAUMgB,EAAoC,SAAC,GAAD,IAAGL,EAAH,EAAGA,MAAOb,EAAV,EAAUA,KAAV,OAC/C,oCACGa,GAAS,uBAAGZ,UAAU,gCAAgCY,GACvD,kBAAC,IAAD,CAAQb,KAAMA","file":"component---src-pages-functions-utility-tsx-d232d5ae80cc1c5377fb.js","sourcesContent":["import React, { FC } from \"react\"\n\ntype InlineCodeProps = {\n  code?: string\n  className?: string\n}\n\nconst InlineCode: FC<InlineCodeProps> = ({\n  code,\n  className,\n  children,\n  ...rest\n}) => {\n  let classes = \"inline-code\"\n  if (className) {\n    classes = `${classes} ${className}`\n  }\n  return (\n    <span className={classes} {...rest}>\n      {code ? code : children}\n    </span>\n  )\n}\n\nexport default InlineCode\n","import { Link } from \"gatsby\"\nimport React, { FC, ReactElement } from \"react\"\nimport InlineCode from \"../../components/inlineCode\"\nimport Layout from \"../../components/layout\"\nimport { CodeExample } from \"../../components/validatorFuncs\"\n\nconst forEachExample = `var validator = new ValidatorBuilder<Employee>()\n    .ForEach(\n        e => e.Skills,\n        builder => \n        {\n            builder.NotNull().MinLength(3);\n        })\n    .Build();\n    \n// this will produce two broken rules\nvar result = validator.Validate(new Employee \n    { \n        Skills = new[] { \"Dev\", \"No\", \"Junk\", null }\n    });\n\nforeach (var rule in result.BrokenRules)\n{\n    Console.WriteLine($\"[{rule.Rule}] {rule.Key} {rule.Message}\")\n}\n\n// output\n// [MinLength] e.Skills[1] Value must have minimum length of 3\n// [NotNull] e.Skills[3] Value cannot be null`\n\nconst messageExample1 = `var validator = new ValidatorBuilder<string>()\n    .StartsWith(\"d\")\n    .EndsWith(\"m\")\n    .Email()\n    .Message(\"This is not a drum\")\n    .Build();\n    \n// this will produce two broken rules (StartsWith,Email)\nvar result = validator.Validate(\"everything is a drum\");\n\nforeach (var rule in result.BrokenRules)\n{\n    Console.WriteLine($\"[{rule.Rule}]: {rule.Message}\")\n}\n\n// output\n// [StartsWith,Email]: This is not a drum`\n\nconst messageExample2 = `var validator = new ValidatorBuilder<string>()\n    .StartsWith(\"d\")\n    .EndsWith(\"m\")\n    .Email()\n    // access the context to build the message\n    .Message(ctx => $\"This is not a drum ({ctx.BrokenRules.Count})\")\n    .Build();\n    \n// this will produce two broken rules (StartsWith,Email)\nvar result = validator.Validate(\"everything is a drum\");\n\nforeach (var rule in result.BrokenRules)\n{\n    Console.WriteLine($\"[{rule.Rule}]: {rule.Message}\")\n}\n\n// output\n// [StartsWith,Email]: This is not a drum (2)`\n\nfunction UtilityFunctions(): ReactElement {\n  return (\n    <Layout>\n      <h1>Utility Functions</h1>\n      <p>\n        These functions can be used with any type when building validation\n        functions.\n      </p>\n      <p>\n        <ul className=\"list\">\n          {[\"ForEach\", \"Message\"].map((func) => (\n            <li>\n              <Link to={`/functions/utility/#${func}`}>{func}</Link>\n            </li>\n          ))}\n        </ul>\n      </p>\n      <hr className=\"my-6\" />\n      <UtilityMethod\n        name=\"ForEach\"\n        description=\"Adds a validator to validate all items in a collection from the target of the selector expression.\"\n        methods={[\n          \"ForEach<T, P>(Expression<Func<T, IEnumerable<P>>> selector, Action<IValidatorBuilder<P>> func)\",\n        ]}\n      >\n        <CodeExample code={forEachExample} />\n      </UtilityMethod>\n      <hr className=\"my-8\" />\n      <UtilityMethod\n        name=\"Message\"\n        description=\"Aggregates broken rules into a single broken rule with the specified message. \n        This function should be added last and only once to the builder to avoid strange results.\"\n        methods={[\n          \"Message<T>(string message)\",\n          \"Message<T>(Func<ValidationContext<T>, string> func)\",\n        ]}\n      >\n        <CodeExample code={messageExample1} label=\"Using message string\" />\n        <CodeExample\n          code={messageExample2}\n          label=\"Using function returning string\"\n        />\n      </UtilityMethod>\n    </Layout>\n  )\n}\n\nexport default UtilityFunctions\n\ntype UtilityMethodProps = {\n  name: string\n  description: string | JSX.Element\n  methods: string[]\n}\n\nconst UtilityMethod: FC<UtilityMethodProps> = ({\n  name,\n  description,\n  methods,\n  children,\n}) => (\n  <div className=\"mb-4\" id={name}>\n    <h2 className=\"font-semibold\">{name}</h2>\n    <p className=\"my-4\">{description}</p>\n    <h5 className=\"font-semibold text-gray-800 text-sm\">Method</h5>\n    <div className=\"my-4\">\n      {methods.map((method) => (\n        <>\n          <InlineCode className=\"text-sm text-blue-600 bg-blue-100 font-semibold\">\n            {method}\n          </InlineCode>\n          <br />\n        </>\n      ))}\n    </div>\n    <h5 className=\"font-semibold text-gray-800 text-sm\">Example Usage</h5>\n    {children}\n  </div>\n)\n","import React, { FC } from \"react\"\nimport InlineCode from \"./inlineCode\"\nimport CSharp from \"./csharp\"\n\ntype FunctionProps = {\n  name: string\n  description: string\n  methods: string[]\n  brokenRule?: string\n}\n\nexport const ValidatorFunction: FC<FunctionProps> = ({\n  name,\n  description,\n  methods,\n  brokenRule,\n  children,\n}) => {\n  return (\n    <div className=\"mb-4\" id={name}>\n      <h2 className=\"font-semibold\">{name}</h2>\n      <p>{description}</p>\n      <h5 className=\"font-semibold text-gray-800 text-sm my-4\">Methods</h5>\n      {methods.map((method) => (\n        <>\n          <InlineCode className=\"text-sm font-semibold text-blue-600 bg-blue-100\">\n            {method}\n          </InlineCode>\n          <br />\n        </>\n      ))}\n      <h5 className=\"font-semibold text-gray-800 text-sm my-4\">Broken Rule</h5>\n      <p className=\"font-semibold font-mono text-sm text-red-600 inline px-1\">\n        {brokenRule}\n      </p>\n      <h5 className=\"font-semibold text-gray-800 text-sm mt-4\">\n        Example Usage\n      </h5>\n      {children}\n    </div>\n  )\n}\n\ntype CodeExampleProps = {\n  code: string\n  label?: string | JSX.Element\n}\n\nexport const CodeExample: FC<CodeExampleProps> = ({ label, code }) => (\n  <>\n    {label && <p className=\"text-gray-700 mb-0 pb-0 mt-4\">{label}</p>}\n    <CSharp code={code} />\n  </>\n)\n"],"sourceRoot":""}